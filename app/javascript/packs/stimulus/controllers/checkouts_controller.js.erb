import { Controller } from "stimulus"

export default class extends Controller {
	// This whole controller although handling some complex logic is currently overcomplicated and could use some refactoring

	static targets = ["form", "payButton", "subtotal", "total", "delivery", "step0", "step1", "step2", "step3", "step4"]

	connect() {
		this.finalStep = 4

		// Attributes must be indexed same as step positions
		this.attributes = [
			"deliveries.address", 
			"deliveries.scheduled_at", 
			"deliveries.instruction", 
			"deliveries.phone", 
			"payment_method_id"
		]

		this.stripe = Stripe('pk_test_Y2HGxcv4B58lA5tEakifsdiC00JK3c15ec');
		const elements = this.stripe.elements();

		this.card = elements.create("card");
		this.card.mount("#card-element");

		this.card.on('change', this.displayStripeErrors)

		this.card.on('focus', (event) => {
			$("#order_payment_method_id_new-card").prop("checked", true).trigger("click")
		})
	}

	attributeToStepNumber(attribute) {
		return this.attributes.indexOf(attribute)
	}

	attributeToStep(attribute) {
		return $(this[`step${this.attributeToStepNumber(attribute)}Target`])
	}

	stepNumberToAttribute(stepNumber) {
		return this.attributes[stepNumber]
	}

	stepNumberToStep(stepNumber) {
		return $(this[`step${stepNumber}Target`])
	}

	stepNumberToErrorOutput(stepNumber) {
		return this.stepNumberToStep(stepNumber).find('.error-output')
	}

	attributeToErrorOutput(attribute) {
		return this.stepNumberToErrorOutput(this.attributeToStepNumber(attribute))
	}

	stepToCollapsable(step) {
		return step.find('div[id*="collapse"]')
	}

	async checkValidity() {
		const response = await fetch(
			routes.check_validity_api_v1_orders_path(),
			{
				method: "POST",
				body: new FormData(this.formTarget)
			}
		)

		const data = await response.json()

		return data
	}

	async fetchSetupIntent() {
		const response = await fetch(
			routes.api_v1_stripe_setup_intents_path(),
			{
				method: "POST"
			}
		)

		const data = await response.json()

		return data
	}

	displayFormErrors(errors, single_attribute=undefined) {
		this.clearFormErrors()

		if (single_attribute) {
			const value = errors[single_attribute]
			errors = {}
			errors[single_attribute] = value
		}

		Object.keys(errors).forEach((key) => {
			const errorOutput = this.attributeToErrorOutput(key)

			errorOutput.text(errors[key])
		})

		this.showFirstStepWithError()
	}

	showFirstStepWithError() {
		const step = $('.step').filter(function() {
			return $(this).find('.error-output').text()	;
		}).first()

		const collapsable = this.stepToCollapsable(step)
		collapsable.collapse('show')
	}

	updateBreakdown(breakdown) {
		this.subtotalTarget.innerText = breakdown.subtotal
		this.deliveryTarget.innerText = breakdown.delivery
		this.totalTarget.innerText = breakdown.total
	}

	confirmCardSetup() {
		const data = this.fetchSetupIntent()

		data
			.then((data) => {
				const clientSecret = data.client_secret

				this.stripe.confirmCardSetup(clientSecret, {
					payment_method: {
		        card: this.card,
		        billing_details: {
		          name: "Placeholder name",
		        }
		      }
				})
				.then(function(result) {
					if (result.error) {
						console.log(result.error)
					} else {
						$("#order_payment_method_id_new-card").val(result.setupIntent.payment_method)
						$("label[for='order_payment_method_id_new-card']").text("Added card")
						$("#stripe-new-card-div").remove()
					}
				})
			})
	}

	displayStripeErrors(event) {
		const displayStripeError = document.getElementById('card-errors');

	  if (event.error) {
	    displayStripeError.textContent = event.error.message;
	  } else {
	    displayStripeError.textContent = '';
	  }
	}

	async createOrder() {
		const response = await fetch(
			routes.api_v1_orders_path(),
			{ 
				method: "POST",
				body: new FormData(this.formTarget)
			}
		)

		const data = await response.json()

		return data
	}

	clearFormErrors() {
		$(".error-output").text("")
	}

	triggerStep(event) {
		event.preventDefault()

		const data = this.checkValidity()

		data
			.then((data) => {
				this.updateBreakdown(data.breakdown) 

				const stepNumber = Number.parseInt(event.target.dataset.step, 10)
				const attribute = this.stepNumberToAttribute(stepNumber)

				if (Object.keys(data.errors).includes(attribute)) {
					this.displayFormErrors(data.errors, attribute)
				} else {
					if (stepNumber >= this.finalStep) {
						this.finalStep = 0

						if (data.valid) {
							this.enablePayButton()
						} else {
							this.displayFormErrors(data.errors)
						}
					} else {
						this.enableCollapseButton(stepNumber + 1)
					}
				}
			})
	}

	showStep(step) {
		this.stepToCollapsable(step).collapse("show")
	}

	enableCollapseButton(stepNumber) {
		this.showStep(this.stepNumberToStep(stepNumber))

		const button = document.querySelector(`button[data-target="#collapse${stepNumber}"`)

		button.setAttribute("data-toggle", "collapse")
		button.classList.add("dropdown-toggle")
	}

	enablePayButton() {
		const button = this.payButtonTarget

		button.style.cursor = "pointer"
		button.disabled = false
		button.classList.remove("btn-secondary")
		button.classList.add("btn-primary")
	}

	async payOrder() {
		const data = this.createOrder()

		data
			.then((data) => {
				if (data.errors) {
					this.displayFormErrors(data.errors)
				} else {
					fetch(
						routes.pay_api_v1_orders_path({ id: data.id }),
						{
							method: "POST"
						}
					)
					.then(response => response.json())
					.then((data) => {
						if (data.status == "succeeded") {
							console.log("SUCCESS!")

							document.location.href = routes.orders_path()
						} else {
							console.log("Something went wrong")
						}
					})
				}
			})
	}
}
